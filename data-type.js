/**
 * Primitive Type
 * - Number
 * - String
 * - Boolean
 * - null
 * - undefined
 * - symbol
 *
 * Reference Type
 * - Object
 *   - Array
 *   - Function
 *   - RegExp
 *   - Set/WeakSet
 *   - Map/WeakMap
 *
 * 왜 두 가지로 나뉘는 지, 저장되는 형태를 통해 살펴본다
 *
 * stack memory
 * 변수/기본형 데이터/정적 할당
 *
 * heap memory
 * 참조형 데이터/동적 할당
 *
 */


var a;
a = 'abc';
/**
 * 변수 a를 선언하고 값을 할당할때 일어나는 일
 * 1. a라는 변수가 담길 메모리 확보, 값은 비어있음
 * 2. 'abc'라는 값이 담길 메모리 확보
 * 3. a라는 변수를 메모리에서 찾고 값에 'abc'의 주소값을 할당
 */
a = 'abcdef';
/**
 * 4. 'abcdef'라는 값이 담길 메모리 확보
 * 5. a라는 변수를 메모리에서 찾고 값에 'abcdef'의 주소값을 할당
 * point: 값을 바꿀때 가리키고 있는 주소값을 직접 바꾼다.
 */

var obj = {
  a: 1,
  b: 'bbb'
}

/**
 * 컴퓨터는 위 동작을 이렇게 처리한다.
 * var obj; // 1. 선언하고
 * obj = { // 2. 할당
 *   a: 1,
 *   b: 'bbb'
 * }
 *
 * 변수 obj를 선언/할당했을 때 일어나는 일
 * 1. obj를 넣을 메모리를 확보
 * 2. 그런데 값 안에 여러 데이터가 있으므로 우선 임의의 큰 메모리 공간을 확보하고 주소만 obj 값에 넣음
 * 3. 값 안의 데이터를 변수와 값으로 각각 메모리해 할당
 * 4. 값의 주소를 obj의 값 안에 할당
 */

obj.a = 2;

/**
 * 객체 안의 값을 바꾸면 일어나는 일
 * 1. 2라는 값이 담길 메모리 확보
 * 2. obj의 값을 메모리에서 찾는다.
 * 3. 값이 가리키는 주소에 가서 a를 찾는다.
 * 4. a의 값을 2를 담은 메모리의 주소로 바꾼다.
 * point
 * - 값을 바꿀 때 가리키고 있는 주소값을 직접 바꾸는 것이 아니라 a의 주소값만 바꾼다.
 * - 참조 카운트가 0인 메모리는 가비지 컬렉터의 청소대상이 되어 수거된다.
 */

/**
 * 왜 값을 직접 저장하지 않고, 주소값을 저장할까?
 * - 만약 값 그대로 저장하면 나중에 그 데이터를 비교할 일이 생겼을 때 값을 직접 비교해야하는 비용이 발생한다.
 * - 주소가 같다면 값이 같다고 정해두면 주소값만 비교하면 되므로 효율적이다.
 * - 이는 새로운 값을 할당하려고 메모리를 조회할때도 효율적이다. 처음만 시간이 걸리고 이후 부터는 주소만 비교하면 되므로 효율적이다.
 * - 중복된 큰 문자열을 여러개 저장한다고 가정하면 메모리 낭비도 심하다.
 * 즉, 같은 값이 메모리상에 오직 하나만 존재하게 함(불변값)으로써 불필요한 메모리 낭비, 조회를 막을 수 있다.
 * 이때문에 기본형 데이터는 불변값이하고 한다.
 *
 * 요약
 * - 값을 직접 저장한다면
 *    - 데이터 할당시에는 빠름(무조건 할당하면 되니까)
 *    - 비교에 비용이 많이 듦
 *    - 메모리 낭비가 심함
 *
 * - 값의 주소를 저장
 *    - 데이터 할당시에는 느림(같은 값이 메모리에 있는지 조회해야하니까)
 *    - 비교에 비용이 들지 않음(주소만 비교하니까)
 *    - 메모리 낭비 최소화
 */

var k = 10;
var i = k;
var obj1 = {c: 10, d: 'ddd'};
var obj2 = obj1;

i = 15; // 기본형: k와 i의 값이 서로 달라짐.
obj2.c = 20; // 참조형: obj1.c와 obj2.c의 값이 같이 변경됨.
/**
 * k = 10; i = 15;
 * obj1.c = 20;
 */



